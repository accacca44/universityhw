Rules useless in parser due to conflicts

   62 $@18: ε


State 26 conflicts: 9 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: ε
    2        | program input

    3 input: SEMICOLON
    4      | var_declaration
    5      | var_assignment
    6      | if_statement
    7      | while_statement
    8      | read_value
    9      | write_value
   10      | error SEMICOLON

   11 var_declaration: TYPE_INT IDENTIFIER SEMICOLON
   12                | TYPE_DOUBLE IDENTIFIER SEMICOLON
   13                | TYPE_BOOL IDENTIFIER SEMICOLON

   14 $@1: ε

   15 var_declaration: TYPE_INT IDENTIFIER ASSIGNMENT_OP $@1 expression SEMICOLON

   16 $@2: ε

   17 var_declaration: TYPE_DOUBLE IDENTIFIER ASSIGNMENT_OP $@2 expression SEMICOLON

   18 $@3: ε

   19 var_declaration: TYPE_BOOL IDENTIFIER ASSIGNMENT_OP $@3 expression SEMICOLON

   20 $@4: ε

   21 var_assignment: IDENTIFIER ASSIGNMENT_OP $@4 expression SEMICOLON

   22 expression: value

   23 $@5: ε

   24 expression: OP_ADD $@5 expression

   25 $@6: ε

   26 expression: OP_SUB $@6 expression

   27 $@7: ε

   28 expression: expression OP_ADD $@7 expression

   29 $@8: ε

   30 expression: expression OP_SUB $@8 expression

   31 $@9: ε

   32 expression: expression OP_MUL $@9 expression

   33 $@10: ε

   34 expression: expression OP_DIV $@10 expression

   35 $@11: ε

   36 expression: expression OP_MOD $@11 expression

   37 $@12: ε

   38 expression: OPEN_PAREN $@12 expression CLOSE_PAREN

   39 logical_expression: expression
   40                   | relational_expression

   41 $@13: ε

   42 logical_expression: relational_expression REL_AND $@13 relational_expression

   43 $@14: ε

   44 logical_expression: relational_expression REL_OR $@14 relational_expression

   45 $@15: ε

   46 logical_expression: REL_NOT OPEN_PAREN $@15 logical_expression CLOSE_PAREN

   47 relational_expression: expression relation expression

   48 relation: REL_EQ
   49         | REL_NOTEQ
   50         | REL_GT
   51         | REL_LT
   52         | REL_GTE
   53         | REL_LTE

   54 value: INTEGER
   55      | TRUE
   56      | FALSE
   57      | DOUBLE
   58      | IDENTIFIER

   59 $@16: ε

   60 $@17: ε

   61 if_statement: KEY_IF OPEN_PAREN $@16 logical_expression CLOSE_PAREN OPEN_BRACE $@17 program CLOSE_BRACE

   62 $@18: ε

   63 $@19: ε

   64 $@20: ε

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE
   66             | KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE
   67             | KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE KEY_ELSE OPEN_BRACE program CLOSE_BRACE

   68 $@21: ε

   69 $@22: ε

   70 while_statement: KEY_WHILE OPEN_PAREN $@21 logical_expression CLOSE_PAREN OPEN_BRACE $@22 program CLOSE_BRACE

   71 read_value: IO_READ OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON

   72 $@23: ε

   73 write_value: IO_WRITE OPEN_PAREN $@23 expression CLOSE_PAREN SEMICOLON


Terminals, with rules where they appear

    $end (0) 0
    error (256) 10 66 67
    IDENTIFIER <variable_name> (258) 11 12 13 15 17 19 21 58 71
    INTEGER <integer_value> (259) 54
    DOUBLE <double_value> (260) 57
    TRUE (261) 55
    FALSE (262) 56
    TYPE_INT (263) 11 15
    TYPE_DOUBLE (264) 12 17
    TYPE_BOOL (265) 13 19
    ASSIGNMENT_OP (266) 15 17 19 21
    REL_AND (267) 42
    REL_OR (268) 44
    REL_NOT (269) 46
    REL_NOTEQ (270) 49
    REL_EQ (271) 48
    REL_LT (272) 51
    REL_GT (273) 50
    REL_LTE (274) 53
    REL_GTE (275) 52
    KEY_WHILE (276) 70
    KEY_IF (277) 61 65 66 67
    KEY_ELSE (278) 65 67
    OP_SUB (279) 26 30
    OP_ADD (280) 24 28
    OP_MUL (281) 32
    OP_DIV (282) 34
    OP_MOD (283) 36
    IO_READ (284) 71
    IO_WRITE (285) 73
    OPEN_BRACE (286) 61 65 66 67 70
    CLOSE_BRACE (287) 61 65 66 67 70
    OPEN_PAREN (288) 38 46 61 65 66 67 70 71 73
    CLOSE_PAREN (289) 38 46 61 65 66 67 70 71 73
    SEMICOLON (290) 3 10 11 12 13 15 17 19 21 71 73


Nonterminals, with rules where they appear

    $accept (36)
        on left: 0
    program (37)
        on left: 1 2
        on right: 0 2 61 65 66 67 70
    input (38)
        on left: 3 4 5 6 7 8 9 10
        on right: 2
    var_declaration (39)
        on left: 11 12 13 15 17 19
        on right: 4
    $@1 (40)
        on left: 14
        on right: 15
    $@2 (41)
        on left: 16
        on right: 17
    $@3 (42)
        on left: 18
        on right: 19
    var_assignment (43)
        on left: 21
        on right: 5
    $@4 (44)
        on left: 20
        on right: 21
    expression <type> (45)
        on left: 22 24 26 28 30 32 34 36 38
        on right: 15 17 19 21 24 26 28 30 32 34 36 38 39 47 73
    $@5 (46)
        on left: 23
        on right: 24
    $@6 (47)
        on left: 25
        on right: 26
    $@7 (48)
        on left: 27
        on right: 28
    $@8 (49)
        on left: 29
        on right: 30
    $@9 (50)
        on left: 31
        on right: 32
    $@10 (51)
        on left: 33
        on right: 34
    $@11 (52)
        on left: 35
        on right: 36
    $@12 (53)
        on left: 37
        on right: 38
    logical_expression <type> (54)
        on left: 39 40 42 44 46
        on right: 46 61 65 70
    $@13 (55)
        on left: 41
        on right: 42
    $@14 (56)
        on left: 43
        on right: 44
    $@15 (57)
        on left: 45
        on right: 46
    relational_expression <type> (58)
        on left: 47
        on right: 40 42 44
    relation (59)
        on left: 48 49 50 51 52 53
        on right: 47
    value <type> (60)
        on left: 54 55 56 57 58
        on right: 22
    if_statement (61)
        on left: 61 65 66 67
        on right: 6
    $@16 (62)
        on left: 59
        on right: 61
    $@17 (63)
        on left: 60
        on right: 61
    $@18 (64)
        on left: 62
        on right: 65
    $@19 (65)
        on left: 63
        on right: 65
    $@20 (66)
        on left: 64
        on right: 65
    while_statement (67)
        on left: 70
        on right: 7
    $@21 (68)
        on left: 68
        on right: 70
    $@22 (69)
        on left: 69
        on right: 70
    read_value (70)
        on left: 71
        on right: 8
    write_value (71)
        on left: 73
        on right: 9
    $@23 (72)
        on left: 72
        on right: 73


State 0

    0 $accept: • program $end

    $default  reduce using rule 1 (program)

    program  go to state 1


State 1

    0 $accept: program • $end
    2 program: program • input

    $end         shift, and go to state 2
    error        shift, and go to state 3
    IDENTIFIER   shift, and go to state 4
    TYPE_INT     shift, and go to state 5
    TYPE_DOUBLE  shift, and go to state 6
    TYPE_BOOL    shift, and go to state 7
    KEY_WHILE    shift, and go to state 8
    KEY_IF       shift, and go to state 9
    IO_READ      shift, and go to state 10
    IO_WRITE     shift, and go to state 11
    SEMICOLON    shift, and go to state 12

    input            go to state 13
    var_declaration  go to state 14
    var_assignment   go to state 15
    if_statement     go to state 16
    while_statement  go to state 17
    read_value       go to state 18
    write_value      go to state 19


State 2

    0 $accept: program $end •

    $default  accept


State 3

   10 input: error • SEMICOLON

    SEMICOLON  shift, and go to state 20


State 4

   21 var_assignment: IDENTIFIER • ASSIGNMENT_OP $@4 expression SEMICOLON

    ASSIGNMENT_OP  shift, and go to state 21


State 5

   11 var_declaration: TYPE_INT • IDENTIFIER SEMICOLON
   15                | TYPE_INT • IDENTIFIER ASSIGNMENT_OP $@1 expression SEMICOLON

    IDENTIFIER  shift, and go to state 22


State 6

   12 var_declaration: TYPE_DOUBLE • IDENTIFIER SEMICOLON
   17                | TYPE_DOUBLE • IDENTIFIER ASSIGNMENT_OP $@2 expression SEMICOLON

    IDENTIFIER  shift, and go to state 23


State 7

   13 var_declaration: TYPE_BOOL • IDENTIFIER SEMICOLON
   19                | TYPE_BOOL • IDENTIFIER ASSIGNMENT_OP $@3 expression SEMICOLON

    IDENTIFIER  shift, and go to state 24


State 8

   70 while_statement: KEY_WHILE • OPEN_PAREN $@21 logical_expression CLOSE_PAREN OPEN_BRACE $@22 program CLOSE_BRACE

    OPEN_PAREN  shift, and go to state 25


State 9

   61 if_statement: KEY_IF • OPEN_PAREN $@16 logical_expression CLOSE_PAREN OPEN_BRACE $@17 program CLOSE_BRACE
   65             | KEY_IF • OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE
   66             | KEY_IF • OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE
   67             | KEY_IF • OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE KEY_ELSE OPEN_BRACE program CLOSE_BRACE

    OPEN_PAREN  shift, and go to state 26


State 10

   71 read_value: IO_READ • OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON

    OPEN_PAREN  shift, and go to state 27


State 11

   73 write_value: IO_WRITE • OPEN_PAREN $@23 expression CLOSE_PAREN SEMICOLON

    OPEN_PAREN  shift, and go to state 28


State 12

    3 input: SEMICOLON •

    $default  reduce using rule 3 (input)


State 13

    2 program: program input •

    $default  reduce using rule 2 (program)


State 14

    4 input: var_declaration •

    $default  reduce using rule 4 (input)


State 15

    5 input: var_assignment •

    $default  reduce using rule 5 (input)


State 16

    6 input: if_statement •

    $default  reduce using rule 6 (input)


State 17

    7 input: while_statement •

    $default  reduce using rule 7 (input)


State 18

    8 input: read_value •

    $default  reduce using rule 8 (input)


State 19

    9 input: write_value •

    $default  reduce using rule 9 (input)


State 20

   10 input: error SEMICOLON •

    $default  reduce using rule 10 (input)


State 21

   21 var_assignment: IDENTIFIER ASSIGNMENT_OP • $@4 expression SEMICOLON

    $default  reduce using rule 20 ($@4)

    $@4  go to state 29


State 22

   11 var_declaration: TYPE_INT IDENTIFIER • SEMICOLON
   15                | TYPE_INT IDENTIFIER • ASSIGNMENT_OP $@1 expression SEMICOLON

    ASSIGNMENT_OP  shift, and go to state 30
    SEMICOLON      shift, and go to state 31


State 23

   12 var_declaration: TYPE_DOUBLE IDENTIFIER • SEMICOLON
   17                | TYPE_DOUBLE IDENTIFIER • ASSIGNMENT_OP $@2 expression SEMICOLON

    ASSIGNMENT_OP  shift, and go to state 32
    SEMICOLON      shift, and go to state 33


State 24

   13 var_declaration: TYPE_BOOL IDENTIFIER • SEMICOLON
   19                | TYPE_BOOL IDENTIFIER • ASSIGNMENT_OP $@3 expression SEMICOLON

    ASSIGNMENT_OP  shift, and go to state 34
    SEMICOLON      shift, and go to state 35


State 25

   70 while_statement: KEY_WHILE OPEN_PAREN • $@21 logical_expression CLOSE_PAREN OPEN_BRACE $@22 program CLOSE_BRACE

    $default  reduce using rule 68 ($@21)

    $@21  go to state 36


State 26

   61 if_statement: KEY_IF OPEN_PAREN • $@16 logical_expression CLOSE_PAREN OPEN_BRACE $@17 program CLOSE_BRACE
   65             | KEY_IF OPEN_PAREN • $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE
   66             | KEY_IF OPEN_PAREN • error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE
   67             | KEY_IF OPEN_PAREN • error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE KEY_ELSE OPEN_BRACE program CLOSE_BRACE

    error  shift, and go to state 37

    IDENTIFIER  reduce using rule 59 ($@16)
    IDENTIFIER  [reduce using rule 62 ($@18)]
    INTEGER     reduce using rule 59 ($@16)
    INTEGER     [reduce using rule 62 ($@18)]
    DOUBLE      reduce using rule 59 ($@16)
    DOUBLE      [reduce using rule 62 ($@18)]
    TRUE        reduce using rule 59 ($@16)
    TRUE        [reduce using rule 62 ($@18)]
    FALSE       reduce using rule 59 ($@16)
    FALSE       [reduce using rule 62 ($@18)]
    REL_NOT     reduce using rule 59 ($@16)
    REL_NOT     [reduce using rule 62 ($@18)]
    OP_SUB      reduce using rule 59 ($@16)
    OP_SUB      [reduce using rule 62 ($@18)]
    OP_ADD      reduce using rule 59 ($@16)
    OP_ADD      [reduce using rule 62 ($@18)]
    OPEN_PAREN  reduce using rule 59 ($@16)
    OPEN_PAREN  [reduce using rule 62 ($@18)]

    $@16  go to state 38
    $@18  go to state 39


State 27

   71 read_value: IO_READ OPEN_PAREN • IDENTIFIER CLOSE_PAREN SEMICOLON

    IDENTIFIER  shift, and go to state 40


State 28

   73 write_value: IO_WRITE OPEN_PAREN • $@23 expression CLOSE_PAREN SEMICOLON

    $default  reduce using rule 72 ($@23)

    $@23  go to state 41


State 29

   21 var_assignment: IDENTIFIER ASSIGNMENT_OP $@4 • expression SEMICOLON

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 50
    value       go to state 51


State 30

   15 var_declaration: TYPE_INT IDENTIFIER ASSIGNMENT_OP • $@1 expression SEMICOLON

    $default  reduce using rule 14 ($@1)

    $@1  go to state 52


State 31

   11 var_declaration: TYPE_INT IDENTIFIER SEMICOLON •

    $default  reduce using rule 11 (var_declaration)


State 32

   17 var_declaration: TYPE_DOUBLE IDENTIFIER ASSIGNMENT_OP • $@2 expression SEMICOLON

    $default  reduce using rule 16 ($@2)

    $@2  go to state 53


State 33

   12 var_declaration: TYPE_DOUBLE IDENTIFIER SEMICOLON •

    $default  reduce using rule 12 (var_declaration)


State 34

   19 var_declaration: TYPE_BOOL IDENTIFIER ASSIGNMENT_OP • $@3 expression SEMICOLON

    $default  reduce using rule 18 ($@3)

    $@3  go to state 54


State 35

   13 var_declaration: TYPE_BOOL IDENTIFIER SEMICOLON •

    $default  reduce using rule 13 (var_declaration)


State 36

   70 while_statement: KEY_WHILE OPEN_PAREN $@21 • logical_expression CLOSE_PAREN OPEN_BRACE $@22 program CLOSE_BRACE

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    REL_NOT     shift, and go to state 55
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression             go to state 56
    logical_expression     go to state 57
    relational_expression  go to state 58
    value                  go to state 51


State 37

   66 if_statement: KEY_IF OPEN_PAREN error • CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE
   67             | KEY_IF OPEN_PAREN error • CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE KEY_ELSE OPEN_BRACE program CLOSE_BRACE

    CLOSE_PAREN  shift, and go to state 59


State 38

   61 if_statement: KEY_IF OPEN_PAREN $@16 • logical_expression CLOSE_PAREN OPEN_BRACE $@17 program CLOSE_BRACE

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    REL_NOT     shift, and go to state 55
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression             go to state 56
    logical_expression     go to state 60
    relational_expression  go to state 58
    value                  go to state 51


State 39

   65 if_statement: KEY_IF OPEN_PAREN $@18 • logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    REL_NOT     shift, and go to state 55
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression             go to state 56
    logical_expression     go to state 61
    relational_expression  go to state 58
    value                  go to state 51


State 40

   71 read_value: IO_READ OPEN_PAREN IDENTIFIER • CLOSE_PAREN SEMICOLON

    CLOSE_PAREN  shift, and go to state 62


State 41

   73 write_value: IO_WRITE OPEN_PAREN $@23 • expression CLOSE_PAREN SEMICOLON

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 63
    value       go to state 51


State 42

   58 value: IDENTIFIER •

    $default  reduce using rule 58 (value)


State 43

   54 value: INTEGER •

    $default  reduce using rule 54 (value)


State 44

   57 value: DOUBLE •

    $default  reduce using rule 57 (value)


State 45

   55 value: TRUE •

    $default  reduce using rule 55 (value)


State 46

   56 value: FALSE •

    $default  reduce using rule 56 (value)


State 47

   26 expression: OP_SUB • $@6 expression

    $default  reduce using rule 25 ($@6)

    $@6  go to state 64


State 48

   24 expression: OP_ADD • $@5 expression

    $default  reduce using rule 23 ($@5)

    $@5  go to state 65


State 49

   38 expression: OPEN_PAREN • $@12 expression CLOSE_PAREN

    $default  reduce using rule 37 ($@12)

    $@12  go to state 66


State 50

   21 var_assignment: IDENTIFIER ASSIGNMENT_OP $@4 expression • SEMICOLON
   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    OP_SUB     shift, and go to state 67
    OP_ADD     shift, and go to state 68
    OP_MUL     shift, and go to state 69
    OP_DIV     shift, and go to state 70
    OP_MOD     shift, and go to state 71
    SEMICOLON  shift, and go to state 72


State 51

   22 expression: value •

    $default  reduce using rule 22 (expression)


State 52

   15 var_declaration: TYPE_INT IDENTIFIER ASSIGNMENT_OP $@1 • expression SEMICOLON

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 73
    value       go to state 51


State 53

   17 var_declaration: TYPE_DOUBLE IDENTIFIER ASSIGNMENT_OP $@2 • expression SEMICOLON

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 74
    value       go to state 51


State 54

   19 var_declaration: TYPE_BOOL IDENTIFIER ASSIGNMENT_OP $@3 • expression SEMICOLON

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 75
    value       go to state 51


State 55

   46 logical_expression: REL_NOT • OPEN_PAREN $@15 logical_expression CLOSE_PAREN

    OPEN_PAREN  shift, and go to state 76


State 56

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression
   39 logical_expression: expression •
   47 relational_expression: expression • relation expression

    REL_NOTEQ  shift, and go to state 77
    REL_EQ     shift, and go to state 78
    REL_LT     shift, and go to state 79
    REL_GT     shift, and go to state 80
    REL_LTE    shift, and go to state 81
    REL_GTE    shift, and go to state 82
    OP_SUB     shift, and go to state 67
    OP_ADD     shift, and go to state 68
    OP_MUL     shift, and go to state 69
    OP_DIV     shift, and go to state 70
    OP_MOD     shift, and go to state 71

    $default  reduce using rule 39 (logical_expression)

    relation  go to state 83


State 57

   70 while_statement: KEY_WHILE OPEN_PAREN $@21 logical_expression • CLOSE_PAREN OPEN_BRACE $@22 program CLOSE_BRACE

    CLOSE_PAREN  shift, and go to state 84


State 58

   40 logical_expression: relational_expression •
   42                   | relational_expression • REL_AND $@13 relational_expression
   44                   | relational_expression • REL_OR $@14 relational_expression

    REL_AND  shift, and go to state 85
    REL_OR   shift, and go to state 86

    $default  reduce using rule 40 (logical_expression)


State 59

   66 if_statement: KEY_IF OPEN_PAREN error CLOSE_PAREN • OPEN_BRACE program CLOSE_BRACE
   67             | KEY_IF OPEN_PAREN error CLOSE_PAREN • OPEN_BRACE program CLOSE_BRACE KEY_ELSE OPEN_BRACE program CLOSE_BRACE

    OPEN_BRACE  shift, and go to state 87


State 60

   61 if_statement: KEY_IF OPEN_PAREN $@16 logical_expression • CLOSE_PAREN OPEN_BRACE $@17 program CLOSE_BRACE

    CLOSE_PAREN  shift, and go to state 88


State 61

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression • CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE

    CLOSE_PAREN  shift, and go to state 89


State 62

   71 read_value: IO_READ OPEN_PAREN IDENTIFIER CLOSE_PAREN • SEMICOLON

    SEMICOLON  shift, and go to state 90


State 63

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression
   73 write_value: IO_WRITE OPEN_PAREN $@23 expression • CLOSE_PAREN SEMICOLON

    OP_SUB       shift, and go to state 67
    OP_ADD       shift, and go to state 68
    OP_MUL       shift, and go to state 69
    OP_DIV       shift, and go to state 70
    OP_MOD       shift, and go to state 71
    CLOSE_PAREN  shift, and go to state 91


State 64

   26 expression: OP_SUB $@6 • expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 92
    value       go to state 51


State 65

   24 expression: OP_ADD $@5 • expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 93
    value       go to state 51


State 66

   38 expression: OPEN_PAREN $@12 • expression CLOSE_PAREN

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 94
    value       go to state 51


State 67

   30 expression: expression OP_SUB • $@8 expression

    $default  reduce using rule 29 ($@8)

    $@8  go to state 95


State 68

   28 expression: expression OP_ADD • $@7 expression

    $default  reduce using rule 27 ($@7)

    $@7  go to state 96


State 69

   32 expression: expression OP_MUL • $@9 expression

    $default  reduce using rule 31 ($@9)

    $@9  go to state 97


State 70

   34 expression: expression OP_DIV • $@10 expression

    $default  reduce using rule 33 ($@10)

    $@10  go to state 98


State 71

   36 expression: expression OP_MOD • $@11 expression

    $default  reduce using rule 35 ($@11)

    $@11  go to state 99


State 72

   21 var_assignment: IDENTIFIER ASSIGNMENT_OP $@4 expression SEMICOLON •

    $default  reduce using rule 21 (var_assignment)


State 73

   15 var_declaration: TYPE_INT IDENTIFIER ASSIGNMENT_OP $@1 expression • SEMICOLON
   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    OP_SUB     shift, and go to state 67
    OP_ADD     shift, and go to state 68
    OP_MUL     shift, and go to state 69
    OP_DIV     shift, and go to state 70
    OP_MOD     shift, and go to state 71
    SEMICOLON  shift, and go to state 100


State 74

   17 var_declaration: TYPE_DOUBLE IDENTIFIER ASSIGNMENT_OP $@2 expression • SEMICOLON
   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    OP_SUB     shift, and go to state 67
    OP_ADD     shift, and go to state 68
    OP_MUL     shift, and go to state 69
    OP_DIV     shift, and go to state 70
    OP_MOD     shift, and go to state 71
    SEMICOLON  shift, and go to state 101


State 75

   19 var_declaration: TYPE_BOOL IDENTIFIER ASSIGNMENT_OP $@3 expression • SEMICOLON
   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    OP_SUB     shift, and go to state 67
    OP_ADD     shift, and go to state 68
    OP_MUL     shift, and go to state 69
    OP_DIV     shift, and go to state 70
    OP_MOD     shift, and go to state 71
    SEMICOLON  shift, and go to state 102


State 76

   46 logical_expression: REL_NOT OPEN_PAREN • $@15 logical_expression CLOSE_PAREN

    $default  reduce using rule 45 ($@15)

    $@15  go to state 103


State 77

   49 relation: REL_NOTEQ •

    $default  reduce using rule 49 (relation)


State 78

   48 relation: REL_EQ •

    $default  reduce using rule 48 (relation)


State 79

   51 relation: REL_LT •

    $default  reduce using rule 51 (relation)


State 80

   50 relation: REL_GT •

    $default  reduce using rule 50 (relation)


State 81

   53 relation: REL_LTE •

    $default  reduce using rule 53 (relation)


State 82

   52 relation: REL_GTE •

    $default  reduce using rule 52 (relation)


State 83

   47 relational_expression: expression relation • expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 104
    value       go to state 51


State 84

   70 while_statement: KEY_WHILE OPEN_PAREN $@21 logical_expression CLOSE_PAREN • OPEN_BRACE $@22 program CLOSE_BRACE

    OPEN_BRACE  shift, and go to state 105


State 85

   42 logical_expression: relational_expression REL_AND • $@13 relational_expression

    $default  reduce using rule 41 ($@13)

    $@13  go to state 106


State 86

   44 logical_expression: relational_expression REL_OR • $@14 relational_expression

    $default  reduce using rule 43 ($@14)

    $@14  go to state 107


State 87

   66 if_statement: KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE • program CLOSE_BRACE
   67             | KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE • program CLOSE_BRACE KEY_ELSE OPEN_BRACE program CLOSE_BRACE

    $default  reduce using rule 1 (program)

    program  go to state 108


State 88

   61 if_statement: KEY_IF OPEN_PAREN $@16 logical_expression CLOSE_PAREN • OPEN_BRACE $@17 program CLOSE_BRACE

    OPEN_BRACE  shift, and go to state 109


State 89

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN • OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE

    OPEN_BRACE  shift, and go to state 110


State 90

   71 read_value: IO_READ OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON •

    $default  reduce using rule 71 (read_value)


State 91

   73 write_value: IO_WRITE OPEN_PAREN $@23 expression CLOSE_PAREN • SEMICOLON

    SEMICOLON  shift, and go to state 111


State 92

   26 expression: OP_SUB $@6 expression •
   28           | expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    OP_MUL  shift, and go to state 69
    OP_DIV  shift, and go to state 70

    $default  reduce using rule 26 (expression)


State 93

   24 expression: OP_ADD $@5 expression •
   28           | expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    OP_MUL  shift, and go to state 69
    OP_DIV  shift, and go to state 70

    $default  reduce using rule 24 (expression)


State 94

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression
   38           | OPEN_PAREN $@12 expression • CLOSE_PAREN

    OP_SUB       shift, and go to state 67
    OP_ADD       shift, and go to state 68
    OP_MUL       shift, and go to state 69
    OP_DIV       shift, and go to state 70
    OP_MOD       shift, and go to state 71
    CLOSE_PAREN  shift, and go to state 112


State 95

   30 expression: expression OP_SUB $@8 • expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 113
    value       go to state 51


State 96

   28 expression: expression OP_ADD $@7 • expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 114
    value       go to state 51


State 97

   32 expression: expression OP_MUL $@9 • expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 115
    value       go to state 51


State 98

   34 expression: expression OP_DIV $@10 • expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 116
    value       go to state 51


State 99

   36 expression: expression OP_MOD $@11 • expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression  go to state 117
    value       go to state 51


State 100

   15 var_declaration: TYPE_INT IDENTIFIER ASSIGNMENT_OP $@1 expression SEMICOLON •

    $default  reduce using rule 15 (var_declaration)


State 101

   17 var_declaration: TYPE_DOUBLE IDENTIFIER ASSIGNMENT_OP $@2 expression SEMICOLON •

    $default  reduce using rule 17 (var_declaration)


State 102

   19 var_declaration: TYPE_BOOL IDENTIFIER ASSIGNMENT_OP $@3 expression SEMICOLON •

    $default  reduce using rule 19 (var_declaration)


State 103

   46 logical_expression: REL_NOT OPEN_PAREN $@15 • logical_expression CLOSE_PAREN

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    REL_NOT     shift, and go to state 55
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression             go to state 56
    logical_expression     go to state 118
    relational_expression  go to state 58
    value                  go to state 51


State 104

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression
   47 relational_expression: expression relation expression •

    OP_SUB  shift, and go to state 67
    OP_ADD  shift, and go to state 68
    OP_MUL  shift, and go to state 69
    OP_DIV  shift, and go to state 70
    OP_MOD  shift, and go to state 71

    $default  reduce using rule 47 (relational_expression)


State 105

   70 while_statement: KEY_WHILE OPEN_PAREN $@21 logical_expression CLOSE_PAREN OPEN_BRACE • $@22 program CLOSE_BRACE

    $default  reduce using rule 69 ($@22)

    $@22  go to state 119


State 106

   42 logical_expression: relational_expression REL_AND $@13 • relational_expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression             go to state 120
    relational_expression  go to state 121
    value                  go to state 51


State 107

   44 logical_expression: relational_expression REL_OR $@14 • relational_expression

    IDENTIFIER  shift, and go to state 42
    INTEGER     shift, and go to state 43
    DOUBLE      shift, and go to state 44
    TRUE        shift, and go to state 45
    FALSE       shift, and go to state 46
    OP_SUB      shift, and go to state 47
    OP_ADD      shift, and go to state 48
    OPEN_PAREN  shift, and go to state 49

    expression             go to state 120
    relational_expression  go to state 122
    value                  go to state 51


State 108

    2 program: program • input
   66 if_statement: KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program • CLOSE_BRACE
   67             | KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program • CLOSE_BRACE KEY_ELSE OPEN_BRACE program CLOSE_BRACE

    error        shift, and go to state 3
    IDENTIFIER   shift, and go to state 4
    TYPE_INT     shift, and go to state 5
    TYPE_DOUBLE  shift, and go to state 6
    TYPE_BOOL    shift, and go to state 7
    KEY_WHILE    shift, and go to state 8
    KEY_IF       shift, and go to state 9
    IO_READ      shift, and go to state 10
    IO_WRITE     shift, and go to state 11
    CLOSE_BRACE  shift, and go to state 123
    SEMICOLON    shift, and go to state 12

    input            go to state 13
    var_declaration  go to state 14
    var_assignment   go to state 15
    if_statement     go to state 16
    while_statement  go to state 17
    read_value       go to state 18
    write_value      go to state 19


State 109

   61 if_statement: KEY_IF OPEN_PAREN $@16 logical_expression CLOSE_PAREN OPEN_BRACE • $@17 program CLOSE_BRACE

    $default  reduce using rule 60 ($@17)

    $@17  go to state 124


State 110

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE • $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE

    $default  reduce using rule 63 ($@19)

    $@19  go to state 125


State 111

   73 write_value: IO_WRITE OPEN_PAREN $@23 expression CLOSE_PAREN SEMICOLON •

    $default  reduce using rule 73 (write_value)


State 112

   38 expression: OPEN_PAREN $@12 expression CLOSE_PAREN •

    $default  reduce using rule 38 (expression)


State 113

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   30           | expression OP_SUB $@8 expression •
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    OP_MUL  shift, and go to state 69
    OP_DIV  shift, and go to state 70

    $default  reduce using rule 30 (expression)


State 114

   28 expression: expression • OP_ADD $@7 expression
   28           | expression OP_ADD $@7 expression •
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    OP_MUL  shift, and go to state 69
    OP_DIV  shift, and go to state 70

    $default  reduce using rule 28 (expression)


State 115

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   32           | expression OP_MUL $@9 expression •
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression

    $default  reduce using rule 32 (expression)


State 116

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   34           | expression OP_DIV $@10 expression •
   36           | expression • OP_MOD $@11 expression

    $default  reduce using rule 34 (expression)


State 117

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression
   36           | expression OP_MOD $@11 expression •

    OP_SUB  shift, and go to state 67
    OP_ADD  shift, and go to state 68
    OP_MUL  shift, and go to state 69
    OP_DIV  shift, and go to state 70

    $default  reduce using rule 36 (expression)


State 118

   46 logical_expression: REL_NOT OPEN_PAREN $@15 logical_expression • CLOSE_PAREN

    CLOSE_PAREN  shift, and go to state 126


State 119

   70 while_statement: KEY_WHILE OPEN_PAREN $@21 logical_expression CLOSE_PAREN OPEN_BRACE $@22 • program CLOSE_BRACE

    $default  reduce using rule 1 (program)

    program  go to state 127


State 120

   28 expression: expression • OP_ADD $@7 expression
   30           | expression • OP_SUB $@8 expression
   32           | expression • OP_MUL $@9 expression
   34           | expression • OP_DIV $@10 expression
   36           | expression • OP_MOD $@11 expression
   47 relational_expression: expression • relation expression

    REL_NOTEQ  shift, and go to state 77
    REL_EQ     shift, and go to state 78
    REL_LT     shift, and go to state 79
    REL_GT     shift, and go to state 80
    REL_LTE    shift, and go to state 81
    REL_GTE    shift, and go to state 82
    OP_SUB     shift, and go to state 67
    OP_ADD     shift, and go to state 68
    OP_MUL     shift, and go to state 69
    OP_DIV     shift, and go to state 70
    OP_MOD     shift, and go to state 71

    relation  go to state 83


State 121

   42 logical_expression: relational_expression REL_AND $@13 relational_expression •

    $default  reduce using rule 42 (logical_expression)


State 122

   44 logical_expression: relational_expression REL_OR $@14 relational_expression •

    $default  reduce using rule 44 (logical_expression)


State 123

   66 if_statement: KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE •
   67             | KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE • KEY_ELSE OPEN_BRACE program CLOSE_BRACE

    KEY_ELSE  shift, and go to state 128

    $default  reduce using rule 66 (if_statement)


State 124

   61 if_statement: KEY_IF OPEN_PAREN $@16 logical_expression CLOSE_PAREN OPEN_BRACE $@17 • program CLOSE_BRACE

    $default  reduce using rule 1 (program)

    program  go to state 129


State 125

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 • program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE

    $default  reduce using rule 1 (program)

    program  go to state 130


State 126

   46 logical_expression: REL_NOT OPEN_PAREN $@15 logical_expression CLOSE_PAREN •

    $default  reduce using rule 46 (logical_expression)


State 127

    2 program: program • input
   70 while_statement: KEY_WHILE OPEN_PAREN $@21 logical_expression CLOSE_PAREN OPEN_BRACE $@22 program • CLOSE_BRACE

    error        shift, and go to state 3
    IDENTIFIER   shift, and go to state 4
    TYPE_INT     shift, and go to state 5
    TYPE_DOUBLE  shift, and go to state 6
    TYPE_BOOL    shift, and go to state 7
    KEY_WHILE    shift, and go to state 8
    KEY_IF       shift, and go to state 9
    IO_READ      shift, and go to state 10
    IO_WRITE     shift, and go to state 11
    CLOSE_BRACE  shift, and go to state 131
    SEMICOLON    shift, and go to state 12

    input            go to state 13
    var_declaration  go to state 14
    var_assignment   go to state 15
    if_statement     go to state 16
    while_statement  go to state 17
    read_value       go to state 18
    write_value      go to state 19


State 128

   67 if_statement: KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE KEY_ELSE • OPEN_BRACE program CLOSE_BRACE

    OPEN_BRACE  shift, and go to state 132


State 129

    2 program: program • input
   61 if_statement: KEY_IF OPEN_PAREN $@16 logical_expression CLOSE_PAREN OPEN_BRACE $@17 program • CLOSE_BRACE

    error        shift, and go to state 3
    IDENTIFIER   shift, and go to state 4
    TYPE_INT     shift, and go to state 5
    TYPE_DOUBLE  shift, and go to state 6
    TYPE_BOOL    shift, and go to state 7
    KEY_WHILE    shift, and go to state 8
    KEY_IF       shift, and go to state 9
    IO_READ      shift, and go to state 10
    IO_WRITE     shift, and go to state 11
    CLOSE_BRACE  shift, and go to state 133
    SEMICOLON    shift, and go to state 12

    input            go to state 13
    var_declaration  go to state 14
    var_assignment   go to state 15
    if_statement     go to state 16
    while_statement  go to state 17
    read_value       go to state 18
    write_value      go to state 19


State 130

    2 program: program • input
   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program • CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE

    error        shift, and go to state 3
    IDENTIFIER   shift, and go to state 4
    TYPE_INT     shift, and go to state 5
    TYPE_DOUBLE  shift, and go to state 6
    TYPE_BOOL    shift, and go to state 7
    KEY_WHILE    shift, and go to state 8
    KEY_IF       shift, and go to state 9
    IO_READ      shift, and go to state 10
    IO_WRITE     shift, and go to state 11
    CLOSE_BRACE  shift, and go to state 134
    SEMICOLON    shift, and go to state 12

    input            go to state 13
    var_declaration  go to state 14
    var_assignment   go to state 15
    if_statement     go to state 16
    while_statement  go to state 17
    read_value       go to state 18
    write_value      go to state 19


State 131

   70 while_statement: KEY_WHILE OPEN_PAREN $@21 logical_expression CLOSE_PAREN OPEN_BRACE $@22 program CLOSE_BRACE •

    $default  reduce using rule 70 (while_statement)


State 132

   67 if_statement: KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE KEY_ELSE OPEN_BRACE • program CLOSE_BRACE

    $default  reduce using rule 1 (program)

    program  go to state 135


State 133

   61 if_statement: KEY_IF OPEN_PAREN $@16 logical_expression CLOSE_PAREN OPEN_BRACE $@17 program CLOSE_BRACE •

    $default  reduce using rule 61 (if_statement)


State 134

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE • KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE

    KEY_ELSE  shift, and go to state 136


State 135

    2 program: program • input
   67 if_statement: KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE KEY_ELSE OPEN_BRACE program • CLOSE_BRACE

    error        shift, and go to state 3
    IDENTIFIER   shift, and go to state 4
    TYPE_INT     shift, and go to state 5
    TYPE_DOUBLE  shift, and go to state 6
    TYPE_BOOL    shift, and go to state 7
    KEY_WHILE    shift, and go to state 8
    KEY_IF       shift, and go to state 9
    IO_READ      shift, and go to state 10
    IO_WRITE     shift, and go to state 11
    CLOSE_BRACE  shift, and go to state 137
    SEMICOLON    shift, and go to state 12

    input            go to state 13
    var_declaration  go to state 14
    var_assignment   go to state 15
    if_statement     go to state 16
    while_statement  go to state 17
    read_value       go to state 18
    write_value      go to state 19


State 136

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE • OPEN_BRACE $@20 program CLOSE_BRACE

    OPEN_BRACE  shift, and go to state 138


State 137

   67 if_statement: KEY_IF OPEN_PAREN error CLOSE_PAREN OPEN_BRACE program CLOSE_BRACE KEY_ELSE OPEN_BRACE program CLOSE_BRACE •

    $default  reduce using rule 67 (if_statement)


State 138

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE • $@20 program CLOSE_BRACE

    $default  reduce using rule 64 ($@20)

    $@20  go to state 139


State 139

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 • program CLOSE_BRACE

    $default  reduce using rule 1 (program)

    program  go to state 140


State 140

    2 program: program • input
   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program • CLOSE_BRACE

    error        shift, and go to state 3
    IDENTIFIER   shift, and go to state 4
    TYPE_INT     shift, and go to state 5
    TYPE_DOUBLE  shift, and go to state 6
    TYPE_BOOL    shift, and go to state 7
    KEY_WHILE    shift, and go to state 8
    KEY_IF       shift, and go to state 9
    IO_READ      shift, and go to state 10
    IO_WRITE     shift, and go to state 11
    CLOSE_BRACE  shift, and go to state 141
    SEMICOLON    shift, and go to state 12

    input            go to state 13
    var_declaration  go to state 14
    var_assignment   go to state 15
    if_statement     go to state 16
    while_statement  go to state 17
    read_value       go to state 18
    write_value      go to state 19


State 141

   65 if_statement: KEY_IF OPEN_PAREN $@18 logical_expression CLOSE_PAREN OPEN_BRACE $@19 program CLOSE_BRACE KEY_ELSE OPEN_BRACE $@20 program CLOSE_BRACE •

    $default  reduce using rule 65 (if_statement)
